---
title: "2.Run models"
author: "Annemarie van der Marel"
date: "2022-12-15"
output: html_document
---
Here, we perform PGLMMS using the brms package as it can examine correlations between continuous and discrete traits, and can incorporate multiple measurements per species.

Analyses: 

monogamy with polygyny -> females do not mate multiply vs promiscuity -> females do mate multiply; models:
  - subset litter size of 1 
  - full dataset

Highlighting litter size of 1 with different mating system -> model subset by litter size of 1
assumption that litter of 1 --> there is no post-copulatory selection  -> confounding effect


This rmarkdown runs the models on the full dataset of 224 species

```{r}
sessionInfo()


#clear garbage; https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/gc
gc()



```



The version of RStan currently available on CRAN is not compatible with R4.2, and displays errors like the following:
"Error in compileCode(f, code, language = language, verbose = verbose) : 
Error in sink(type = "output") : invalid connection"

Instead, you will need to install the preview of rstan 2.26 using:
```{r}
install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
```
See https://github.com/stan-dev/rstan/wiki/Configuring-C---Toolchain-for-Windows

I changed back to R version 4.1.2 as I still received the error. 

# Load libraries
```{r setup, include=FALSE}
# data cleaning
library(tidyverse) 
library(job) # to run models in the background

# phylogenies
library(phytools)
library(ape)

# PGLMMs
library(brms)
library(rstan)
library(rlang)
library(Rcpp)
#library("loo")

#library(rethinking)

```
https://cran.r-project.org/web/packages/loo/vignettes/loo2-example.html#using-the-loo-package-for-model-checking-and-comparison 


Stan settings
```{r}
mycores <- parallel::detectCores() - 2

options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```


# Import data
```{r}

rts_df <- read.csv("../data/rts_life_mating_care.csv") %>%
  dplyr::select(-X)

species<- unique(rts_df$Binomial)
#write.csv(species, "species571.csv")


unique(rts_df$mating_system)
rts_df$mating_system[rts_df$mating_system=="monogamous; polygynous"] <- "polygynous"
unique(rts_df$order)

df <- rts_df %>%
  select(order, family, common_name, Binomial, 
         rts, 
         litter_size, litter_year, longevity, 
         mating_system, paternal_care) %>%
  mutate(females_mate_multiply = if_else(mating_system=="monogamous", "no",
                                         if_else(mating_system=="polygynous", "no","yes")))



```


## distribution

```{r}
ggplot(df, aes(rts)) +
  geom_histogram()

# shapiro test p >0.05, data normally distributed
#ggqqplot(rts_df, "rts")
shapiro.test(df$rts)


m <- lm(rts ~ litter_size, data = rts_df)
summary(m)
d <- data.frame(residuals = residuals(m),         # Residuals
                std_residuals = rstudent(m), # Studentized Residuals
                fitted = fitted(m),          # Fitted values
                cooks = cooks.distance(m))   # Cook's D
d <- mutate(d, observation = 1:nrow(d))           # Observation number

# histogram of residuals
ggplot(data = d, aes(x = std_residuals)) +
  geom_histogram(bins = 10)

# Check for Normality: QQ Normality plot of residuals
ggplot(data = d, aes(sample = std_residuals)) +
  stat_qq() +
  stat_qq_line()

# Check heteroscedasticity or constant variance
ggplot(d, aes(x = fitted, y = std_residuals)) +
  geom_point() +
  geom_hline(yintercept = 0)

# Cook's D
ggplot(d, aes(x = observation, y = cooks)) +
  geom_point() +
  geom_hline(yintercept = 1, linetype = "dotted") +
  geom_hline(yintercept = 4/nrow(d), linetype = "dashed")
# outliers
d_outliers <- filter(d, cooks > 4/nrow(d))  # observation 86
#rts_df[59,]
rts_df[550,] # Sorex_araneus largest Cook's distance

#d_outliers # no outliers when log-transformed; 2,31,33,34


# distribution
fitdistrplus::plotdist(df$rts)
fitdistrplus::descdist(df$rts, discrete = FALSE)
fit.gamma <- fitdistrplus::fitdist(df$rts, 'gamma')
plot(fit.gamma)
fit.gamma$aic
fit.weibull <- fitdistrplus::fitdist(df$rts, "weibull")
plot(fit.weibull)
fit.weibull$aic
fit.norm <- fitdistrplus::fitdist(df$rts, "norm")
plot(fit.norm)
fit.norm$aic
fit.lnorm <- fitdistrplus::fitdist(df$rts, "lnorm")
plot(fit.lnorm)
fit.lnorm$aic

# (gamlss)
library(gamlss)
fit <- fitDist(df$rts, k = 2, type = "realline", trace = FALSE, try.gamlss = TRUE)
summary(fit)
fit$fits  # best fit: c("SHASHo", "Sinh-Arcsinh")  
fit$failed



# brms
# fitting a brms model with a Gaussian likelihood
job::job({
model_normal <- brm(rts ~ 1, family = gaussian(), data = df)

# fitting a brms model with a gamma
model_gamma <- brm(rts ~ 1, family = Gamma(), data = df)

# fitting a brms model with a skew normal likelihood
model_skew <- brm(rts ~ 1, family = skew_normal(), data = df)

# fitting a brms model with a log normal likelihood
model_lnorm <- brm(rts ~ 1, family = lognormal(), data = df)

# fitting a brms model with a weibull likelihood
model_weib <- brm(rts ~ 1, family = weibull(), data = df)
})

# posterior predictive checking
pp_check(model_normal, ndraws = 1e2)  
pp_check(model_gamma, ndraws = 1e2)
pp_check(model_skew, ndraws = 1e2)
pp_check(model_lnorm, ndraws = 1e2) # lognormal best fitting distribution
pp_check(model_weib, ndraws = 1e2) 
```

# select species trait data
We select species with data for all our predictor variables

```{r}
select_df <- na.omit(df) 
n_distinct(select_df$Binomial)
n_distinct(select_df$order)
```


# Import phylogenetic tree

-	a mammalian phylogenetic tree
o	Upham et al. 2019 https://doi.org/10.1371/journal.pbio.3000494 
o	http://vertlife.org/phylosubsets/ website to select species or taxonomic groups or complete tree 
tree-pruner-812b7edc-05f3-4f07-9665-eb3a3cd861e0 for complete 571 species


```{r}
# Upham et al. 2019
#mammaltree <- read.nexus("./data/output.nex")
trees <- ape::read.nexus("../data/571mammals.nex")
```



## plot tree
```{r}

pdf(file = "./figures/sampletree.pdf", width = 9, height = 30)
plot(tree)
dev.off()
```

## check tree
```{r}
# species names in tree
sort(trees[[1]]$tip.label)

#mammaltree
#str(mammaltree)



TipsWant <- unique(select_df$Binomial) # 220 species that have all trait data

# Only include the species that are present in our dataset
tree.tr = drop.tip(tree, setdiff(tree$tip.label, TipsWant))
str(tree.tr)
plot.phylo(tree.tr)
tree.tr$tip.label
plot(tree.tr); axisPhylo()

# list of taxa with traits that are not in the phylogeny 
remove.table = setdiff(TipsWant, tree$tip.label)
remove.table # no species missing in phylogeny 

# remove from table all species that are not in phylogeny -> not necessary
# pruned_df = df[!(TipsWant %in% remove.table), ]
# #st<- st %>% filter(Binomial %in% TipsWant) %>% droplevels() # other way
# unique(pruned_df$Binomial)
# length(unique(pruned_df$Binomial))
```

# intercept only model


### set up model species with trait data
standardize values
```{r}
st<-  select_df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st)
```

```{r}
# duplicate species list for mixed-effects model
st$phylo<- st$Binomial
```


filter species with trait data from phylogeny
```{r}
TipsWant <- unique(select_df$Binomial) # 224 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```



### set up model all species
filter species with trait data from phylogeny
```{r}

# 571 species that have all trait data
TipsWantAll <- unique(df$Binomial) 

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWantAll))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```

standardize values
```{r}
st_intercept<-  df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st_intercept)
```

```{r}
# duplicate species list for mixed-effects model
st_intercept$phylo<- st_intercept$Binomial
```

###Get prior 
https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf
https://discourse.mc-stan.org/t/help-understanding-and-setting-informative-priors-in-brms/9574/12
sample_prior = "only" and then creating prior predictive plots via pp_check.
```{r}
prior.intercept<- brms::get_prior(rts ~ 1 +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data =  st, #st_intercept, 
          data2 = list(A = A[[1]]),
          family = lognormal())
prior.intercept

```

### model

model convergence diagnositcs:
"We may also investigate convergence numerically by means of the
scale reduction factor Rb (Gelman and Rubin 1992; Gelman et al. 2013; Vehtari et al. 2019), which should be close to one (i.e., R < b 1.05), 
and the effective sample size, which should be as large as possible but at least 400 to merely ensure reliable convergence diagnostics " Burkner (2021)
```{r}

job::job({
m.intercept <- brm(rts ~ 1 +
              (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st, #st_intercept, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.intercept, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(m.intercept)
summary(m.intercept, waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
loo(m.intercept) #, moment_match = TRUE
pp_check(m.intercept) 
plot(m.intercept, ask=FALSE)


# extract samples
intercept.samples<- posterior_samples(m.intercept)
intercept.draws <- as_draws(m.intercept)
intercept.loo <- loo(m.intercept)$estimate[3]

```



### loop for all 100 trees

```{r}


i=1
list <- c(1:100)

## loo
  intercept.looic  <- data.frame(runby=character(),
                                 looic=numeric())
## posterior samples
  samplesi <-  colnames(intercept.samples) 
  intercept.samples1 <- data.frame(matrix(nrow = 0, ncol = length(samplesi)))
  colnames(intercept.samples1) <- samplesi # assign column names


for(i in 1:100){
  runby <- list[i]
  print(runby)

  pruned.tree <- drop.tip(trees[[runby]], 
                          setdiff(trees[[runby]]$tip.label, TipsWant)) # TipsWantAll
  A <- vcv.phylo(pruned.tree)

  
  m.intercepti <- brm(rts ~ 1 +
              (1|gr(Binomial, cov = A)) + (1|phylo), 
  data = st, #st_intercept, 
  family = lognormal(), 
  data2 = list(A = A),
  prior = prior.intercept, 
  chains = 4, cores = mycores, 
  iter = 5000, warmup = 3000,  
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  )

  # model fit
  looic <- loo(m.intercepti)$estimate[3]
  pool <- cbind.data.frame(runby, 
                           looic)
  intercept.looic <-rbind(intercept.looic , pool )
  write.csv(intercept.looic,"../results/loo.intercept.looped.csv" )
  
  # extract samples
  intercept.samplesi<- posterior_samples(m.intercepti)
  post.intercept.looped<- rbind(intercept.samples1, intercept.samplesi)
  save(post.intercept.looped, file="../results/post.intercept.looped_run1-100.robj")
  
  # extract samples
  # intercept.samplesi<- posterior_samples(m.intercepti)
  # intercept.post.looped<- rbind(intercept.samples, intercept.samplesi)
  # save( intercept.post.looped, file=" intercept.post.looped.robj")
  # 
  # intercept.drawsi <- as_draws(m.intercepti)
  # intercept.post.draw.looped<- rbind(intercept.draws, intercept.drawsi)
  # save(intercept.post.draw.looped, file="intercept.post.draw.looped.robj")
}

  


#save(interactioni, file="interactionmodel.looped.robj")
```






# mating system 
## global model

### set up model
filter species with trait data from phylogeny
```{r}
TipsWant <- unique(select_df$Binomial) # 220 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```

standardize values
```{r}
st<-  select_df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st)
```

```{r}
# duplicate species list for mixed-effects model
st$phylo<- st$Binomial
```

Get prior 
https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf
https://discourse.mc-stan.org/t/help-understanding-and-setting-informative-priors-in-brms/9574/12
sample_prior = "only" and then creating prior predictive plots via pp_check.
```{r}
prior.global <- brms::get_prior(rts ~ litter_size + litter_year + longevity +
               mating_system + paternal_care +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st, 
          data2 = list(A = A[[1]]),
          family = lognormal())
prior.global

prior <- brms::get_prior(rts ~ 1 +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st, 
          data2 = list(A = A[[1]]),
            
          family = lognormal())

```

### model

model convergence diagnositcs:
"We may also investigate convergence numerically by means of the
scale reduction factor Rb (Gelman and Rubin 1992; Gelman et al. 2013; Vehtari et al. 2019), which should be close to one (i.e., R < b 1.05), 
and the effective sample size, which should be as large as possible but at least 400 to merely ensure reliable convergence diagnostics " Burkner (2021)
```{r}

job::job({
global <- brm(rts ~ litter_size + litter_year + longevity +
                     mating_system + paternal_care +
                     (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.global, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(global)
summary(global, waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
loo(global) #, moment_match = TRUE
pp_check(global) 
plot(global, ask=FALSE)


# extract samples
global.samples<- posterior_samples(global)
global.draws <- as_draws(global)




```



### loop for all 100 trees

```{r}

#job::job({
i=1
list <- c(1:100)

# make empty data frame to put data in
## loo
global.looic  <- data.frame(runby=character(),
                            looic=numeric())
## posterior samples
  samplesg <-  colnames(global.samples) 
  global.samples1 <- data.frame(matrix(nrow = 0, ncol = length(samplesg)))
  colnames(global.samples1) <- samplesg # assign column names


for(i in 1:100){
  runby <- list[i]
  print(runby)

  pruned.tree <- drop.tip(trees[[runby]], setdiff(trees[[runby]]$tip.label, TipsWant))
  A <- vcv.phylo(pruned.tree)

  
  globali <- brm(rts ~ litter_size + litter_year + longevity +
                     mating_system + paternal_care +
                     (1|gr(Binomial, cov = A)) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A),
  prior = prior.global, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, 
                 max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )

  # model fit
  looic <- loo(globali)$estimate[3]
  pool <- cbind.data.frame(runby, 
                           looic)
  global.looic <-rbind(global.looic , pool )
  write.csv(global.looic,"../results/loo.global.looped.csv" )
  
  # extract samples
  global.samplesi<- posterior_samples(globali)
  post.global.looped<- rbind(global.samples1, global.samplesi)
  save(post.global.looped, file="../results/post.global.looped_run1-100.robj")
  
  
  # global.samplesi<- posterior_samples(globali)
  # post.global.looped<- rbind(global.samples, global.samplesi)
  # save(post.global.looped, file="post.global.looped.robj")
  #
  # global.drawsi <- as_draws(globali)
  # post.global.draw.looped<- rbind(global.draws, global.drawsi)
  # save(post.global.draw.looped, file="post.global.draw.looped.robj")
}


  
nrow(post.global.looped)/4000 # check all 100 models added 

```
We received for some of the runs the warning:
Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-essWarning -> model on tree 1 seemed to be doing fine. 

Also some runs had some obersvations with pareto_k > 0.7. It is recommended to set 'moment_match = TRUE' in order to perform moment matching for problematic observations.


## global model within species variability

add variability of the independent variables (predictor) within species
We only have repeated measures of testes mass and body mass of 23 species, so we will get rts data for 23 species.  

```{r}
# get mean of repeated measures 
st_mean<-st

st_mean$mean_rts <- 
  with(st, sapply(split(rts, Binomial), mean)[Binomial])

head(st_mean)

## add variability of the independent variables (predictor) within species
# as only rts change within species, we only have to add rts
st_mean$within_rts <- st_mean$rts - st_mean$mean_rts
```

```{r}

#filter species with trait data from phylogeny

TipsWant <- unique(st_mean$Binomial) # 220 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)




# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}


# set prior
prior.within =  brms::get_prior(mean_rts ~ within_rts + 
                                  litter_size + litter_year + longevity +
               mating_system + paternal_care +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st_mean, 
          data2 = list(A = A[[1]]),
          family = lognormal())



job::job({
global_within_sp <- brm(mean_rts ~ within_rts + 
                        litter_size + litter_year + longevity +
                        mating_system + paternal_care +
                        (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st_mean, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.within, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(global_within_sp)
summary(global_within_sp, waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
loo(global_within_sp) #, moment_match = TRUE
pp_check(global_within_sp) 
plot(global_within_sp, ask=FALSE)


# extract samples
global_within_sp.samples<- posterior_samples(global_within_sp)
global_within_sp.draws <- as_draws(global_within_sp)

```
no model convergence. It took very long to run. We will not run this on the 99 other phylogenetic trees. 

## interaction model
We hypothesized that the relationship between testes size and female reproductive output would differ between mammal species exhibiting different mating systems.  Specifically, in species where females mate with multiple males per breeding attempt, we predicted larger testes size with smaller litter sizes and fewer total annual offspring, because smaller litter sizes represent more intense competition due to fewer potential offspring available to be sired. In species where females mate with a single male per breeding attempt, we predicted larger testes with larger litter sizes and greater numbers of total annual offspring, due to lesser competition with other males, but an increased need to fertilize eggs.

female reproductive investment = litter size * litters/year 


### set up model

standardize values
```{r}
st<-  select_df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st)
```

```{r}
# duplicate species list for mixed-effects model
st$phylo<- st$Binomial
```


filter species with trait data from phylogeny
```{r}
TipsWant <- unique(st$Binomial) # 224 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```


Get prior 
https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf
https://discourse.mc-stan.org/t/help-understanding-and-setting-informative-priors-in-brms/9574/12
sample_prior = "only" and then creating prior predictive plots via pp_check.
```{r}
prior.interaction<- brms::get_prior(rts ~ litter_size * litter_year * mating_system +
                                  longevity + paternal_care +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st, 
          data2 = list(A = A[[1]]),
          family = lognormal())
prior.interaction

```

### model

model convergence diagnositcs:
"We may also investigate convergence numerically by means of the
scale reduction factor Rb (Gelman and Rubin 1992; Gelman et al. 2013; Vehtari et al. 2019), which should be close to one (i.e., R < b 1.05), 
and the effective sample size, which should be as large as possible but at least 400 to merely ensure reliable convergence diagnostics " Burkner (2021)
```{r}

job::job({
m.int <- brm(rts ~ litter_size * litter_year * mating_system +
              longevity + paternal_care +
              (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.interaction, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(m.int)
summary(m.int, waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
pp_check(m.int) 
plot(m.int, ask=FALSE)

loo(m.int) #, moment_match = TRUE
loo.interaction <- loo(m.int)$estimate[3]

# extract samples
inter.samples<- posterior_samples(m.int)
inter.draws <- as_draws(m.int)
inter.looic <- loo(m.int)$estimate[3]
#inter.loo <- rbind(1, inter.looic)
#inter.loo <- loo(m.int, save_psis = TRUE)
#inter.looic <- loo(m.int)[["looic"]] -> deprecated

#loo
# print(inter.loo)
# plot(inter.loo)
# if (any(pareto_k_values(inter.loo) > 0.7)) {
#   inter.loo1 <- loo(m.int, save_psis = TRUE, k_threshold = 0.7)#, moment_match = T
# }
# print(inter.loo1)
# 
# loo_compare(loo, inter.loo)

```




### loop for all 100 trees

```{r}
start.time <- Sys.time()

#job::job({
i=1
list <- c(1:100)

# make empty data frame to put data in
## loo
inter.looic <- data.frame(runby=character(),
                          looic=numeric())
## posterior samples
  samples <-  colnames(inter.samples) 
  inter.samples1 <- data.frame(matrix(nrow = 0, ncol = length(samples)))
  colnames(inter.samples1) <- samples # assign column names

for(i in 1:100){
  runby <- list[i]
  print(runby)

  pruned.tree <- drop.tip(trees[[runby]], setdiff(trees[[runby]]$tip.label, TipsWant))
  A <- vcv.phylo(pruned.tree)

  
  interactioni <- brm(rts ~ litter_size * litter_year * mating_system +
              longevity + paternal_care +
              (1|gr(Binomial, cov = A)) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A),
  prior = prior.interaction, 
  chains = 4, cores = mycores, 
  iter = 5000, warmup = 3000,  
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  )

  # model fit
  #inter.looi <- loo(interactioni)[["looic"]]
  looic <- loo(interactioni)$estimate[3]
  pool <- cbind.data.frame(runby, 
                           looic)
  inter.looic <-rbind(inter.looic, pool )
  write.csv(inter.looic,"../results/loo.interaction.looped.csv" )
  #save(inter.looi, file="loo.interaction.looped.robj")
  
  # extract samples
  inter.samplesi<- posterior_samples(interactioni)
  post.inter.looped<- rbind(inter.samples1, inter.samplesi)
  save(post.inter.looped, file="../results/post.interaction.looped_run1-100.robj")
  
  # # have to combine lists
  # inter.drawsi <- as_draws(interactioni)
  # post.inter.draw.looped<- rbind(sample.draws, inter.drawsi)
  # save(post.inter.draw.looped, file="post.inter.draw.looped_run1-100.robj")
}
#})
end.time <- Sys.time()

#Time to run:
end.time - start.time
  
nrow(post.inter.looped)/2000 # check all 100 models added 

#save(interactioni, file="interactionmodel.looped.robj")
```


#  females multiple mate
## global model

### set up model
filter species with trait data from phylogeny
```{r}
TipsWant <- unique(select_df$Binomial) # 220 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```

standardize values
```{r}
st<-  select_df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st)
```

```{r}
# duplicate species list for mixed-effects model
st$phylo<- st$Binomial
```

Get prior 
https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf
https://discourse.mc-stan.org/t/help-understanding-and-setting-informative-priors-in-brms/9574/12
sample_prior = "only" and then creating prior predictive plots via pp_check.
```{r}
prior.global.fmm <- brms::get_prior(rts ~ litter_size + litter_year + longevity +
               females_mate_multiply + paternal_care +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st, 
          data2 = list(A = A[[1]]),
          family = lognormal())


```

### model

model convergence diagnositcs:
"We may also investigate convergence numerically by means of the
scale reduction factor Rb (Gelman and Rubin 1992; Gelman et al. 2013; Vehtari et al. 2019), which should be close to one (i.e., R < b 1.05), 
and the effective sample size, which should be as large as possible but at least 400 to merely ensure reliable convergence diagnostics " Burkner (2021)
```{r}

job::job({
global.fmm <- brm(rts ~ litter_size + litter_year + longevity +
                     females_mate_multiply + paternal_care +
                     (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.global.fmm, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(global.fmm )
summary(global.fmm , waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
loo(global.fmm ) #, moment_match = TRUE
pp_check(global.fmm ) 
plot(global.fmm , ask=FALSE)


# extract samples
fmm.global.samples<- posterior_samples(global.fmm)
fmm.global.draws <- as_draws(global.fmm)




```



### loop for all 100 trees

```{r}

#job::job({
i=1
list <- c(1:100)

# make empty data frame to put data in
## loo
fmm.global.looic  <- data.frame(runby=character(),
                            looic=numeric())
## posterior samples
  samplesgfmm <-  colnames(fmm.global.samples) 
  fmm.global.samples1 <- data.frame(matrix(nrow = 0, ncol = length(samplesgfmm)))
  colnames(fmm.global.samples1) <- samplesgfmm # assign column names


for(i in 1:100){
  runby <- list[i]
  print(runby)

  pruned.tree <- drop.tip(trees[[runby]], setdiff(trees[[runby]]$tip.label, TipsWant))
  A <- vcv.phylo(pruned.tree)

  
  fmm.globali <- brm(rts ~ litter_size + litter_year + longevity +
                     females_mate_multiply + paternal_care +
                     (1|gr(Binomial, cov = A)) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A),
  prior = prior.global.fmm, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, 
                 max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )

  # model fit
  looic <- loo(fmm.globali)$estimate[3]
  pool <- cbind.data.frame(runby, 
                           looic)
  fmm.global.looic <-rbind(fmm.global.looic , pool )
  write.csv(fmm.global.looic,"../results/loo.fmm.global.looped.csv" )
  
  # extract samples
  fmm.global.samplesi<- posterior_samples(fmm.globali)
  post.fmm.global.looped<- rbind(fmm.global.samples1, fmm.global.samplesi)
  save(post.fmm.global.looped, file="../results/post.fmm.global.looped.robj")
  
}



```



## interaction model
We hypothesized that the relationship between testes size and female reproductive output would differ between mammal species exhibiting different mating systems.  Specifically, in species where females mate with multiple males per breeding attempt, we predicted larger testes size with smaller litter sizes and fewer total annual offspring, because smaller litter sizes represent more intense competition due to fewer potential offspring available to be sired. In species where females mate with a single male per breeding attempt, we predicted larger testes with larger litter sizes and greater numbers of total annual offspring, due to lesser competition with other males, but an increased need to fertilize eggs.

female reproductive investment = litter size * litters/year 


### set up model

standardize values
```{r}
st<-  select_df %>% 
  mutate(across(c("litter_size", "litter_year", "longevity"), scale)) # standardize values
#st$Binomial
head(st)
```

```{r}
# duplicate species list for mixed-effects model
st$phylo<- st$Binomial
```


filter species with trait data from phylogeny
```{r}
TipsWant <- unique(st$Binomial) # 224 species that have all trait data

pruned.tree <- list() 
for(i in 1:100){
  pruned.tree[[i]]<- drop.tip(trees[[i]], setdiff(trees[[i]]$tip.label, TipsWant))
}
#sort(pruned.tree[[1]]$tip.label)
```


Covariance matrix
```{r}
# convert to covariance matrix (see https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html)
A<- list() 
for(i in 1:100){
  A[[i]]<- vcv.phylo(pruned.tree[[i]])
}
```


Get prior 
https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations
http://www.stat.columbia.edu/~gelman/research/published/entropy-19-00555-v2.pdf
https://discourse.mc-stan.org/t/help-understanding-and-setting-informative-priors-in-brms/9574/12
sample_prior = "only" and then creating prior predictive plots via pp_check.
```{r}
prior.interaction.fmm<- brms::get_prior(rts ~ litter_size * litter_year * 
                                      females_mate_multiply +
                                  longevity + paternal_care +
            (1|gr(Binomial, cov = A[[1]])) +  (1|phylo), 
          data = st, 
          data2 = list(A = A[[1]]),
          family = lognormal())
prior.interaction.fmm

```

### model

model convergence diagnositcs:
"We may also investigate convergence numerically by means of the
scale reduction factor Rb (Gelman and Rubin 1992; Gelman et al. 2013; Vehtari et al. 2019), which should be close to one (i.e., R < b 1.05), 
and the effective sample size, which should be as large as possible but at least 400 to merely ensure reliable convergence diagnostics " Burkner (2021)
```{r}

job::job({
m.int.fmm <- brm(rts ~ litter_size * litter_year * females_mate_multiply +
              longevity + paternal_care +
              (1|gr(Binomial, cov = A[[1]])) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A[[1]]),
  prior = prior.interaction.fmm, #c(prior(student_t(3, 0, 2.5))) 
  chains = 4, cores = mycores, # sample_prior = TRUE / "only"
  iter = 5000, warmup = 3000,  # iter = 10000, warmup = 1500,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  #, save_pars = save_pars(all = TRUE)
  )
})

# check summary, plot for diagnostics --> all good
#rhat(global)
#neff_ratio(global)
pairs(m.int.fmm)
summary(m.int.fmm, waic = TRUE)
#head(predict(global)) # predict responses based on the fitted model

# investigate model fit
pp_check(m.int.fmm) 
plot(m.int.fmm, ask=FALSE)

loo(m.int.fmm) #, moment_match = TRUE
loo.interaction.fmm <- loo(m.int.fmm)$estimate[3]

# extract samples
inter.fmm.samples<- posterior_samples(m.int.fmm)
inter.fmm.draws <- as_draws(m.int.fmm)
inter.fmm.looic <- loo(m.int.fmm)$estimate[3]


```




### loop for all 100 trees

```{r}
start.time <- Sys.time()

#job::job({
i=1
list <- c(1:100)

# make empty data frame to put data in
## loo
inter.looic.fmm <- data.frame(runby=character(),
                          looic=numeric())
## posterior samples
  samples.fmm <-  colnames(inter.fmm.samples) 
  inter.fmm.samples1 <- data.frame(matrix(nrow = 0, ncol = length(samples.fmm)))
  colnames(inter.fmm.samples1) <- samples.fmm # assign column names

for(i in 1:100){
  runby <- list[i]
  print(runby)

  pruned.tree <- drop.tip(trees[[runby]], setdiff(trees[[runby]]$tip.label, TipsWant))
  A <- vcv.phylo(pruned.tree)

  
  fmm.interactioni <- brm(rts ~ litter_size * litter_year * female_mate_multiply +
              longevity + paternal_care +
              (1|gr(Binomial, cov = A)) + (1|phylo), 
  data = st, 
  family = lognormal(), 
  data2 = list(A = A),
  prior = prior.interaction.fmm, 
  chains = 4, cores = mycores, 
  iter = 5000, warmup = 3000,  
  control = list(adapt_delta = 0.99, max_treedepth = 15)
  )

  # model fit
  #inter.looi <- loo(interactioni)[["looic"]]
  looic <- loo(fmm.interactioni)$estimate[3]
  pool <- cbind.data.frame(runby, 
                           looic)
  inter.looic.fmm <-rbind(inter.looic.fmm, pool )
  write.csv(inter.looic.fmm,"../results/loo.fmm.interaction.looped.csv" )
  
  # extract samples
  inter.fmm.samplesi<- posterior_samples(fmm.interactioni)
  post.fmm.inter.looped<- rbind(inter.fmm.samples1, inter.fmm.samplesi)
  save(post.fmm.inter.looped, file="../results/post.fmm.interaction.looped.robj")
  
  # # have to combine lists
  # inter.drawsi <- as_draws(interactioni)
  # post.inter.draw.looped<- rbind(sample.draws, inter.drawsi)
  # save(post.inter.draw.looped, file="post.inter.draw.looped_run1-100.robj")
}
#})
end.time <- Sys.time()

#Time to run:
end.time - start.time
  



```


